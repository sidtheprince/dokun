//////////////////////////////////////////////
// embeding a custom library into the Lua interpreter
lualib.h:
#define LUA_ENGINELIBNAME "dokun"
LUAMOD_API int (luaopen_dokun) (lua_State *L);

linit.c:
{"dokun", luaopen_dokun},

lua.c : surround "main()" function with :
#ifdef DOKUN_BUILD_CONSOLE
#endif

luac.c: surround "main" function with:
#ifdef DOKUN_BUILD_COMPILER
#endif
/////////////////////////////////////////////

engine.cpp: 
// register engine functions to Lua (dokun.start, dokun.close, dokun.test, etc.)
    static const luaL_Reg module[] = 
    {
		{"start" , Engine::open  },
	    {"close" , Engine::close },
		{"test"  , Engine::test  },
        {nullptr , nullptr       },
    };	

#ifdef __cplusplus // if c++
extern "C" {       // run code as c  (if you do not do this, dokun will not work in Lua)
#endif		
	
static int register_dokun_module_to_lua(lua_State *L)	{
#ifndef DOKUN_LUA51
    luaL_newlibtable(L, module);
    luaL_setfuncs   (L, module, 0);	// luaL_newlib(L, module) is equivalent to (luaL_newlibtable(L,l), luaL_setfuncs(L,l,0))
#endif
#ifdef DOKUN_LUA51
	lua_newtable (L);
	luaL_register(L, "dokun", module);
#endif	
	return 1;	// return table library	
}	

LUA_API int luaopen_dokun (lua_State *L)
{
	Engine::open          (L);              // initialize engine by default in Lua (so user does not have to do it manually)
	return register_dokun_module_to_lua(L);
}

#ifdef __cplusplus // if c++
}
#endif
/////////////////////////////////////////////
registering table and table_functions:
	Script::table   (L, "Sprite");                                       // same as: Sprite = {} Sprite_mt = {__index=Sprite}
	Script::function(L, "Sprite", "new"         , Sprite::sprite_new  ); // Sprite:new() : creates a C++ Sprite obj and attaches it to a table as 'udata'
	Script::function(L, "Sprite", "destroy"     , Sprite::destroy     ); // Sprite:destroy() : calls on the C++ Sprite destructor
/////////////////////////////////////////////
/////////////////////////////////////////////
/////////////////////////////////////////////
/////////////////////////////////////////////
/////////////////////////////////////////////




int Engine::test(lua_State *L)
{
	WINDOW window;
	window.create("Test", 1280, 720, 0); // titlebar is 16x39 //window.set_size(1500, 900);
	window.show();
    //=================== script
	//Script * script = new Script(L, "config.lua"); // load script
    //=================== sprite
	Sprite * sprite = new Sprite();
	Texture * texture = new Texture();//("res/image.png");
	sprite->set_texture(*texture); // set empty texture to sprite
	sprite->set_color(0, 51, 102);
	sprite->set_position(200, 200);
    //=================== image
    //=================== widget
	Widget * widget = new Widget();
	widget->set_position(500, 500);
	widget->set_title_bar(true);
	widget->set_title_bar_size(20);
    widget->set_title_bar_button_close(true);
	widget->set_outline(true);
    //=================== label
	Label * label = new Label();
	//label->set_parent(*widget);
	label->set_string("Hello Dokun!"); // size set on 'set_string'
	label->set_scale(0.5, 0.5);//size(276, 34);//label->set_size(100, 32);//size(100, 32);
	//===================
    //===================
	double fps_desired = 60;
    //=================== fixed time step
    double t = 0.0;
    double dt = 1.0 / 60.0;
    //t += dt;
    //=================== variable time step (recommended)
    double old_time = 0; 
    double new_time = (clock() / (double)CLOCKS_PER_SEC);
    double delta_time;
    //===================
    //Renderer::get_light()->set_enabled(true);
	// SPRITE VERTICES
	std::vector<float> sprite_vertex_array; 
    sprite_vertex_array.clear();
	sprite_vertex_array.push_back(sprite->get_position().x);
	sprite_vertex_array.push_back(sprite->get_position().y);
	sprite_vertex_array.push_back(sprite->get_position().x + sprite->get_texture()->get_width());
	sprite_vertex_array.push_back(sprite->get_position().y);
	sprite_vertex_array.push_back(sprite->get_position().x + sprite->get_texture()->get_width());
	sprite_vertex_array.push_back(sprite->get_position().y + sprite->get_texture()->get_height());
	sprite_vertex_array.push_back(sprite->get_position().x);
	sprite_vertex_array.push_back(sprite->get_position().y + sprite->get_texture()->get_height());	
    //===================
    while(window.is_open()) // main loop
    {
		window.set_viewport(window.get_client_width(), window.get_client_height());
		window.clear(32, 32, 32);
		
        old_time = new_time;
        new_time = (clock() / (double)CLOCKS_PER_SEC) * 1000;// get time in milliseconds or something; increments by the 100s
        delta_time = new_time - old_time;
        //std::cout << "delta_time: " << delta_time << "\n";
        //std::cout << "time(ms): " << Timer::milliseconds() << "\n";
		std::cout << "window: "         << window.get_size       () << "\n";
        std::cout << "window_client: "  << window.get_client_size() << "\n";
        std::cout << "renderer_client: "<< Renderer::get_display_size() << "\n";
		
	    if(window.is_focused()) // if window is focused
	    {
			if(Keyboard::is_pressed(DOKUN_KEY_UP   )) sprite->translate(0, -1 * delta_time);
			if(Keyboard::is_pressed(DOKUN_KEY_DOWN )) sprite->translate(0, 1 * delta_time );
			if(Keyboard::is_pressed(DOKUN_KEY_LEFT )) sprite->translate(-1 * delta_time, 0);
			if(Keyboard::is_pressed(DOKUN_KEY_RIGHT)) sprite->translate(1 * delta_time, 0 );
		}
		//  draw here
        sprite->draw();
		widget->draw();
		
		window.update();
	}
	window.destroy();       // destroy window
	//====================
	if(!window.is_open()) { // window is closed
		Engine::close(L);   // close engine too
	}
	/*
	Matrix4 m = Matrix4(0); // new matrix allocated with all values set to 0
	m = Matrix4::translate(m, 0, 0, -1.0);
	m = Matrix4::rotate(m, 0 * 0.0174533, 0, 0, 1);
	m = Matrix4::scale(m, 1, 1, 0.0);
	m = Matrix4::translate(m, -0, -0, 1.0);
	//m = Matrix4::ortho(0.0f, 1280, 720, 0.0f, -1.0f, 1.0f);
	//m = Matrix4::perspective(67.5f, static_cast<float>(1280 / 720), 1.0f, 10024.0f);
	m = Matrix4::look_at(0, 0, 0,   0, 0,-1,   0, 1, 0);*/
	return 0;
}
/////////////////////////////////////////////
/*#ifdef __gnu_linux__
#ifdef DOKUN_X11
	Window winFocus;
    int    revert;
    Display * display = XOpenDisplay(nullptr);
	XGetInputFocus(display, &winFocus, &revert);
	XWindowAttributes gwa;
	XGetWindowAttributes(display, winFocus, &gwa); // get attributes while app is running; only gets width and height no x and y
	window_width  = gwa.width ;
	XCloseDisplay(display);
#endif
#endif */
////////////////////////////////////////////
			// Draw default_button images
			//if(close_button) {
			    //Image * closeb = new Image(*Resource::get_image("close_button")); // do NOT allocate an image object in a loop
	            //closeb->set_position(widget->get_title_bar_button_close_position());
	            //closeb->resize(widget->get_title_bar_button_close_size());//scale_to_fit(widget->get_title_bar_button_close_size());
	            //closeb->set_color(widget->get_color());
				//if(Mouse::is_over(title_bar_button_close->get_position(), title_bar_button_close->get_size()))
					//title_bar_button_close_color->set_color(227,38,54); else title_bar_button_close_color->set_color(color);
			//}
////////////////////////////////////////////
library installation guide: http://www.linuxfromscratch.org/blfs/view/svn/general/
////////////////////////////////////////////
////////////////////////////////////////////
